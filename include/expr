#pragma once
#include <token>
#include <vector>
#include <stack>
#include <memory>

struct Binary;
struct Assign;
struct Grouping;
struct Literal;
struct Unary;
struct Call;
struct Variable;
struct Ternary;


struct ExprVisitor {
	virtual std::any visitBinaryExpr(Binary& expr) = 0;
	virtual std::any visitAssignExpr(Assign& expr) = 0;
	virtual std::any visitGroupingExpr(Grouping& expr) = 0;
	virtual std::any visitLiteralExpr(Literal& expr) = 0;
	virtual std::any visitUnaryExpr(Unary& expr) = 0;
	virtual std::any visitCallExpr(Call& expr) = 0;
	virtual std::any visitVariableExpr(Variable& expr) = 0;
	virtual std::any visitTernaryExpr(Ternary& expr) = 0;
};

struct Expr {
	virtual std::any accept(ExprVisitor& visitor) = 0;
	virtual ~Expr() = default;
};

typedef std::unique_ptr<Expr> ExprPtr;

struct Binary : Expr {
	const ExprPtr left;
	const Token* op;
	const ExprPtr right;

	Binary(ExprPtr left, const Token* op, ExprPtr right)
		: left(std::move(left)), op(op), right(std::move(right)) {};

	std::any accept(ExprVisitor& visitor) { return visitor.visitBinaryExpr(*this); }
};

struct Assign : Expr {
	const Token* name;
	const ExprPtr value;

	Assign(const Token* name, ExprPtr value)
		: name(name), value(std::move(value)) {};

	std::any accept(ExprVisitor& visitor) { return visitor.visitAssignExpr(*this); }
};

struct Grouping : Expr {
	const ExprPtr expression;

	Grouping(ExprPtr expression)
		: expression(std::move(expression)) {};

	std::any accept(ExprVisitor& visitor) { return visitor.visitGroupingExpr(*this); }
};

struct Literal : Expr {
	const std::any value;

	Literal(std::any value)
		: value(value) {};

	std::any accept(ExprVisitor& visitor) { return visitor.visitLiteralExpr(*this); }
};

struct Unary : Expr {
	const Token* op;
	const ExprPtr right;

	Unary(const Token* op, ExprPtr right)
		: op(op), right(std::move(right)) {};

	std::any accept(ExprVisitor& visitor) { return visitor.visitUnaryExpr(*this); }
};

struct Call : Expr {
	const ExprPtr callee;
	const Token* paren;
	const std::vector<ExprPtr> args;

	Call(ExprPtr callee, const Token* paren, std::vector<ExprPtr> args)
		: callee(std::move(callee)), paren(paren), args(std::move(args)) {};

	std::any accept(ExprVisitor& visitor) { return visitor.visitCallExpr(*this); }
};

struct Variable : Expr {
	const Token* label;

	Variable(const Token* label)
		: label(label) {};

	std::any accept(ExprVisitor& visitor) { return visitor.visitVariableExpr(*this); }
};

struct Ternary : Expr {
	const ExprPtr condition;
	const ExprPtr true_case;
	const ExprPtr false_case;

	Ternary(ExprPtr condition, ExprPtr true_case, ExprPtr false_case)
		: condition(std::move(condition)), true_case(std::move(true_case)), false_case(std::move(false_case)) {};

	std::any accept(ExprVisitor& visitor) { return visitor.visitTernaryExpr(*this); }
};

