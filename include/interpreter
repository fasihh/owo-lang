#pragma once
#include <stmt>
#include <environment>

class Interpreter : ExprVisitor, StmtVisitor<nullptr_t> {
private:
  int mode;
  
  std::any evaluate(Expr& expr);
  nullptr_t execute(Stmt& stmt);
  
  bool is_equal(const std::any& left, const std::any& right);
  bool is_truthy(const std::any& obj);
  void check_number_operand(const Token* token, const std::any& obj);
  void check_number_operands(const Token* token, const std::any& left, const std::any& right);
public:
  Environment* env;
  void execute_block(const std::vector<std::unique_ptr<Stmt>>& stmts, Environment* env);

  Interpreter();
  ~Interpreter();

  void interpret(const std::vector<std::unique_ptr<Stmt>>& stmts);
  void set_mode(const int mode);

  std::any visitBinaryExpr(Binary& expr) override;
  std::any visitAssignExpr(Assign& expr) override;
  std::any visitGroupingExpr(Grouping& expr) override;
  std::any visitLiteralExpr(Literal& expr) override;
  std::any visitUnaryExpr(Unary& expr) override;
  std::any visitCallExpr(Call& expr) override;
  std::any visitVariableExpr(Variable& expr) override;
  std::any visitTernaryExpr(Ternary& expr) override;

  void visitExpressionStmt(Expression& stmt) override;
  void visitVarStmt(Var& stmt) override;
  void visitBlockStmt(Block& stmt) override;
  void visitIfStmt(If& stmt) override;
  void visitFunctionStmt(Function& stmt) override;
  void visitReturnStmt(Return& stmt) override;
};